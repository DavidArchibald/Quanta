#!/usr/bin/env python3

import signal
import sys
import threading

import discord
from discord.ext import commands

from typing import Union, Callable, Optional
from types import FrameType

exit_handler = None

class ExitHandler:
    def __init__(self: ExitHandler) -> None:
        self.commands_running: int = ...
        self.lock: threading.Lock = ...
        self.SIGTERM: bool = ...

        self.original_sigint: Union[
            Callable, signal.SIG_IGN, signal.SIG_DFL, None
        ] = ...
        self.original_sigterm: Union[
            Callable, signal.SIG_IGN, signal.SIG_DFL, None
        ] = ...
    async def on_command(self: ExitHandler, ctx: commands.Context): ...
    async def on_command_completion(self: ExitHandler, ctx: commands.Context): ...
    async def on_command_error(
        self: ExitHandler, ctx: commands.Context, error: Exception
    ): ...
    def signal_terminate_handler(
        self: ExitHandler, signal: int, frame: Optional[FrameType]
    ): ...
    def signal_interupt_handler(
        self: ExitHandler, signal: int, frame: Optional[FrameType]
    ): ...
    def create_signals(self: ExitHandler): ...
    def is_terminating(self: ExitHandler) -> bool: ...
    def terminate(self: ExitHandler): ...
    def cancel_terminate(self: ExitHandler): ...
    def get_commands_running(self: ExitHandler) -> int: ...

def get_exit_handler() -> ExitHandler: ...
def init(bot: commands.Bot) -> ExitHandler: ...
